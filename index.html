<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Excel 日付クリック塗りつぶし</title>
  <meta name="description" content="Excelのシートを読み込み、日付セルをクリックすると色を塗りつぶすシンプルなWebアプリ。ローカル保存・JSONエクスポート対応。" />
  <!-- Tailwind CDN（デザイン用。不要なら削除可） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- SheetJS（xlsxパーサ） -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    /* テーブルの基本スタイル */
    table.sheet { border-collapse: collapse; table-layout: fixed; width: 100%; font-size: 12px; }
    .sheet th, .sheet td { border: 1px solid #e5e7eb; padding: 6px 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .sheet thead th { position: sticky; top: 0; background: #f8fafc; z-index: 2; }
    .sheet .row-head { position: sticky; left: 0; background: #f8fafc; z-index: 1; width: 56px; min-width: 56px; }
    .sheet td { cursor: default; }
    .sheet td.date-cell { cursor: pointer; }
    /* クリックで塗られる色（変数 --paint を使用） */
    .sheet td.painted { background: var(--paint, #fef08a); }/* 大きいシートのときスクロール領域に影 */
.scroll-shadow { box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06); }

/* スクロール時の見出し境界 */
.sticky-divider { box-shadow: 0 1px 0 0 rgba(0,0,0,0.05); }

  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <header class="px-4 sm:px-6 lg:px-8 py-4 bg-white sticky top-0 z-30 border-b border-slate-200">
    <div class="max-w-6xl mx-auto flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <h1 class="text-xl font-semibold tracking-tight">Excel 日付クリック塗りつぶし</h1>
      <div class="flex flex-wrap items-center gap-2">
        <label class="inline-flex items-center gap-2 px-3 py-2 rounded-xl border bg-white">
          <span class="text-sm">塗り色</span>
          <input id="colorPicker" type="color" class="w-8 h-8 p-0 border-0 cursor-pointer" value="#fef08a"/>
        </label>
        <button id="btnExportState" class="px-3 py-2 rounded-xl bg-slate-900 text-white text-sm hover:bg-slate-800">状態をJSON保存</button>
        <label class="px-3 py-2 rounded-xl bg-white border text-sm cursor-pointer hover:bg-slate-50">
          JSON読込
          <input id="importStateInput" type="file" accept="application/json" class="hidden" />
        </label>
        <button id="btnClear" class="px-3 py-2 rounded-xl bg-white border text-sm hover:bg-slate-50">塗りを全解除</button>
        <a id="repoLink" class="text-sm underline text-slate-600 hover:text-slate-900" href="https://github.com/new" target="_blank" rel="noreferrer">GitHubに新規公開</a>
      </div>
    </div>
  </header>  <main class="max-w-6xl mx-auto p-4 sm:p-6 lg:p-8">
    <!-- コントロールパネル -->
    <section class="bg-white rounded-2xl border shadow-sm p-4 sm:p-6 mb-4">
      <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
        <label class="flex items-center gap-3">
          <span class="text-sm font-medium whitespace-nowrap">Excel 読み込み</span>
          <input id="fileInput" class="block w-full text-sm" type="file" accept=".xlsx,.xls,.csv" />
        </label>
        <div class="flex items-center gap-2">
          <label class="text-sm" for="sheetSelect">シート</label>
          <select id="sheetSelect" class="text-sm border rounded-xl px-3 py-2 bg-white"></select>
        </div>
        <div class="text-xs text-slate-500" id="limitNote" hidden></div>
        <div class="ml-auto text-xs text-slate-500" id="fileMeta"></div>
      </div>
    </section><!-- シート表示領域 -->
<section class="bg-white rounded-2xl border shadow-sm overflow-hidden">
  <div class="sticky top-[72px] bg-white sticky-divider px-4 py-2 text-sm text-slate-600 flex items-center justify-between">
    <div>日付セルをクリックで <span class="font-semibold">塗り/解除</span> できます（ローカルに自動保存）</div>
    <div class="hidden sm:block text-xs">※ Excel自体の塗りは変更されません。共有したい場合は「状態をJSON保存」を使ってください。</div>
  </div>
  <div id="tableWrap" class="max-h-[70vh] overflow-auto scroll-shadow">
    <div class="p-6 text-sm text-slate-500">上の「Excel 読み込み」から .xlsx/.xls/.csv を選んでください。</div>
  </div>
</section>

<!-- 使い方 -->
<section class="mt-6 text-sm text-slate-600 leading-7">
  <h2 class="text-base font-semibold mb-2">使い方</h2>
  <ol class="list-decimal ml-6 space-y-1">
    <li>「Excel 読み込み」でファイルを選びます（ブラウザ内でのみ処理。アップロードされません）。</li>
    <li>シートを選択すると内容が表で表示されます。</li>
    <li>日付が入っているセルをクリックすると塗り/解除されます。</li>
    <li>塗り状態は <span class="font-semibold">localStorage</span> に自動保存され、次回同じファイルを開くと復元されます。</li>
    <li>共有したい場合は「状態をJSON保存」で書き出し、「JSON読込」で別端末でも復元できます。</li>
  </ol>
  <p class="mt-3 text-xs text-slate-500">※ このアプリはExcelファイル自体のスタイルを書き換えません（SheetJSの無償版ではセル塗り書き出しが非対応のため）。必要なら拡張実装も可能です。</p>
</section>

  </main>  <script>
    // ====== ユーティリティ ======
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

    const textEncoder = new TextEncoder();

    async function sha256Hex(ab) {
      const hash = await crypto.subtle.digest('SHA-256', ab);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function downloadFile(filename, data, type='application/octet-stream') {
      const blob = new Blob([data], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function columnLabel(n) { // 0-index -> A, B, ...
      let s = ''; n++;
      while (n) { const m = (n - 1) % 26; s = String.fromCharCode(65 + m) + s; n = Math.floor((n - 1) / 26); }
      return s;
    }

    function looksLikeDateFormat(z) {
      if (!z || typeof z !== 'string') return false;
      // Excelの表示形式で日付っぽいかをざっくり判定
      return /(y|m{1,4}|d{1,4}|yy|yyyy|mmm|dddd)/i.test(z) && !/h+:?m+/i.test(z); // 時刻のみは除外
    }

    function looksLikeDateText(w) {
      if (!w || typeof w !== 'string') return false;
      // 2025/08/17, 2025-08-17, 8/17, 8-17 などざっくり
      return /^(\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}|\d{1,2}[\/\-]\d{1,2})$/.test(w.trim());
    }

    function fmtCell(cell) {
      try { return XLSX.utils.format_cell(cell); } catch { return String(cell?.v ?? ''); }
    }

    // ====== アプリ状態 ======
    let g = {
      ab: null, // ArrayBuffer of file
      fileName: '',
      fileHash: '',
      wb: null, // XLSX.WorkBook
      sheetName: '',
      sheetLimit: { maxRows: 800, maxCols: 120 }, // レンダリング制限（重すぎ対策）
      paintColor: '#fef08a',
    };

    function makeStorageKey(fileHash, sheetName) {
      return `paint:${fileHash}:${sheetName}`;
    }

    function loadLocalState(fileHash, sheetName) {
      const raw = localStorage.getItem(makeStorageKey(fileHash, sheetName));
      if (!raw) return { color: g.paintColor, cells: [] };
      try { return JSON.parse(raw); } catch { return { color: g.paintColor, cells: [] }; }
    }

    function saveLocalState(fileHash, sheetName, state) {
      localStorage.setItem(makeStorageKey(fileHash, sheetName), JSON.stringify(state));
    }

    // ====== DOM refs ======
    const fileInput = document.getElementById('fileInput');
    const sheetSelect = document.getElementById('sheetSelect');
    const tableWrap = document.getElementById('tableWrap');
    const colorPicker = document.getElementById('colorPicker');
    const btnExportState = document.getElementById('btnExportState');
    const importStateInput = document.getElementById('importStateInput');
    const btnClear = document.getElementById('btnClear');
    const fileMeta = document.getElementById('fileMeta');
    const limitNote = document.getElementById('limitNote');

    // ====== ファイル読込 ======
    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      g.fileName = f.name;
      const ab = await f.arrayBuffer();
      g.ab = ab;
      g.fileHash = await sha256Hex(ab);
      fileMeta.textContent = `${g.fileName} / SHA-256: ${g.fileHash.slice(0, 10)}…`;

      // CSVは内部でシート化される
      const wb = XLSX.read(ab, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' });
      g.wb = wb;
      sheetSelect.innerHTML = '';
      wb.SheetNames.forEach((name, i) => {
        const opt = document.createElement('option');
        opt.value = name; opt.textContent = name; if (i === 0) opt.selected = true;
        sheetSelect.appendChild(opt);
      });
      g.sheetName = wb.SheetNames[0] || '';
      renderSheet(g.sheetName);
    });

    sheetSelect.addEventListener('change', (e) => {
      g.sheetName = e.target.value;
      renderSheet(g.sheetName);
    });

    colorPicker.addEventListener('input', () => {
      g.paintColor = colorPicker.value || '#fef08a';
      const table = tableWrap.querySelector('table.sheet');
      if (table) table.style.setProperty('--paint', g.paintColor);
      // ついでに保存中の色も更新
      const st = loadLocalState(g.fileHash, g.sheetName);
      st.color = g.paintColor; saveLocalState(g.fileHash, g.sheetName, st);
    });

    btnExportState.addEventListener('click', () => {
      if (!g.fileHash || !g.sheetName) return;
      const st = loadLocalState(g.fileHash, g.sheetName);
      const payload = { version: 1, fileHash: g.fileHash, sheetName: g.sheetName, ...st };
      downloadFile(`paint-state_${g.sheetName}.json`, JSON.stringify(payload, null, 2), 'application/json');
    });

    importStateInput.addEventListener('change', async (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      const text = await f.text();
      try {
        const obj = JSON.parse(text);
        if (!obj || typeof obj !== 'object' || !obj.sheetName || !obj.fileHash) throw new Error('形式が不正です');
        // 現在のファイルとハッシュが違うと適用せず警告
        if (obj.fileHash !== g.fileHash) {
          alert('この状態JSONは異なるExcelファイルのものです。元のExcelを開いた上で再度読み込んでください。');
          importStateInput.value = '';
          return;
        }
        saveLocalState(g.fileHash, obj.sheetName, { color: obj.color || '#fef08a', cells: obj.cells || [] });
        if (obj.sheetName === g.sheetName) applyPaintFromState();
        alert('状態を適用しました。');
      } catch (err) {
        alert('JSONの読み込みに失敗しました: ' + err.message);
      } finally {
        importStateInput.value = '';
      }
    });

    btnClear.addEventListener('click', () => {
      if (!g.fileHash || !g.sheetName) return;
      const table = tableWrap.querySelector('table.sheet');
      if (!table) return;
      table.querySelectorAll('td.painted').forEach(td => td.classList.remove('painted'));
      saveLocalState(g.fileHash, g.sheetName, { color: g.paintColor, cells: [] });
    });

    // ====== レンダリング ======
    function renderSheet(name) {
      const ws = g.wb?.Sheets?.[name];
      if (!ws) { tableWrap.innerHTML = '<div class="p-6 text-sm text-slate-500">このシートは空です。</div>'; return; }

      const ref = ws['!ref'] || 'A1';
      const range = XLSX.utils.decode_range(ref);
      const totalRows = (range.e.r - range.s.r + 1);
      const totalCols = (range.e.c - range.s.c + 1);

      const maxRows = Math.min(totalRows, g.sheetLimit.maxRows);
      const maxCols = Math.min(totalCols, g.sheetLimit.maxCols);

      limitNote.hidden = (totalRows <= maxRows && totalCols <= maxCols);
      if (!limitNote.hidden) {
        limitNote.textContent = `表示を制限しています（${maxRows}/${totalRows} 行, ${maxCols}/${totalCols} 列）。必要なら上限値をコード内で調整してください。`;
      }

      const table = document.createElement('table');
      table.className = 'sheet';
      table.style.setProperty('--paint', g.paintColor);

      const thead = document.createElement('thead');
      const thr = document.createElement('tr');
      const corner = document.createElement('th');
      corner.className = 'row-head'; corner.textContent = '#';
      thr.appendChild(corner);
      for (let c = 0; c < maxCols; c++) {
        const th = document.createElement('th');
        th.textContent = columnLabel(c);
        thr.appendChild(th);
      }
      thead.appendChild(thr);

      const tbody = document.createElement('tbody');
      for (let r = 0; r < maxRows; r++) {
        const tr = document.createElement('tr');
        const rowHead = document.createElement('th');
        rowHead.className = 'row-head'; rowHead.textContent = (r + 1).toString();
        tr.appendChild(rowHead);
        for (let c = 0; c < maxCols; c++) {
          const rr = range.s.r + r;
          const cc = range.s.c + c;
          const addr = XLSX.utils.encode_cell({ r: rr, c: cc });
          const cell = ws[addr];
          const td = document.createElement('td');
          td.dataset.addr = addr;

          let isDate = false;
          if (cell) {
            const t = cell.t;
            if (t === 'd') isDate = true; // 既に日付型
            else if (t === 'n' && looksLikeDateFormat(cell.z)) isDate = true; // 数値 + 日付書式
            else if ((t === 's' || t === 'n') && looksLikeDateText(cell.w || cell.v)) isDate = true; // 文字列上で日付らしい
            td.textContent = fmtCell(cell);
          } else {
            td.textContent = '';
          }

          if (isDate) {
            td.classList.add('date-cell');
            td.title = `クリックで塗り/解除 (${addr})`;
            td.addEventListener('click', () => togglePaint(td));
          }

          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      table.appendChild(thead);
      table.appendChild(tbody);

      tableWrap.innerHTML = '';
      tableWrap.appendChild(table);

      applyPaintFromState();
    }

    function togglePaint(td) {
      td.classList.toggle('painted');
      persistPaint();
    }

    function persistPaint() {
      if (!g.fileHash || !g.sheetName) return;
      const table = tableWrap.querySelector('table.sheet');
      if (!table) return;
      const addrs = $$('.painted', table).map(td => td.dataset.addr).filter(Boolean);
      saveLocalState(g.fileHash, g.sheetName, { color: g.paintColor, cells: addrs });
    }

    function applyPaintFromState() {
      const table = tableWrap.querySelector('table.sheet');
      if (!table) return;
      const st = loadLocalState(g.fileHash, g.sheetName);
      g.paintColor = st.color || g.paintColor; // カラーピッカーも同期
      colorPicker.value = g.paintColor;
      table.style.setProperty('--paint', g.paintColor);
      // いったん全解除
      table.querySelectorAll('td.painted').forEach(td => td.classList.remove('painted'));
      // 適用
      (st.cells || []).forEach(addr => {
        const td = table.querySelector(`td[data-addr="${addr}"]`);
        if (td) td.classList.add('painted');
      });
    }

    // 初期化（色だけ反映）
    document.addEventListener('DOMContentLoaded', () => {
      const table = tableWrap.querySelector('table.sheet');
      if (table) table.style.setProperty('--paint', g.paintColor);
    });
  </script></body>
</html>        <button id="rebuildBtn" class="btn btn-primary">再生成</button>
        <button id="todayBtn" class="btn btn-secondary">今日へジャンプ</button>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="exportBtn" class="btn btn-secondary">進捗をエクスポート</button>
        <label class="btn btn-secondary cursor-pointer">
          進捗をインポート
          <input id="importInput" type="file" accept="application/json" class="hidden" />
        </label>
        <button id="resetBtn" class="btn btn-secondary">全部リセット</button>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow p-3">
      <h2 class="font-semibold mb-2">今日のToDo</h2>
      <div id="todayList" class="text-sm text-gray-800"></div>
    </div>

    <div class="bg-white rounded-lg shadow p-3 overflow-auto">
      <table id="grid" class="min-w-full text-sm">
        <thead class="sticky top-0 bg-white z-10">
          <tr>
            <th class="sticky-th p-2 text-left">学習項目</th>
            <th class="p-2 nowrap">初回</th>
            <th class="p-2 nowrap">0</th>
            <th class="p-2 nowrap">0.5 (夜)</th>
            <th class="p-2 nowrap">1</th>
            <th class="p-2 nowrap">2</th>
            <th class="p-2 nowrap">3</th>
            <th class="p-2 nowrap">4</th>
            <th class="p-2 nowrap">5</th>
            <th class="p-2 nowrap">6</th>
            <th class="p-2 nowrap">7</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <details class="bg-white rounded-lg shadow p-3">
      <summary class="cursor-pointer font-semibold">ヘルプ</summary>
      <ul class="list-disc ml-5 text-sm text-gray-700 space-y-1 mt-2">
        <li>セルをタップ（クリック）で状態を切り替え：未完 → 完了（緑）。</li>
        <li>「今日のToDo」からもチェックすると、表側のセルが連動して塗られます。</li>
        <li>進捗は端末の <code>localStorage</code> に保存。エクスポート/インポートで他端末に移行可能。</li>
        <li>開始日や1日の新規数を変えたら「再生成」。</li>
      </ul>
    </details>
  </div>

  <script>
  // ---------------- Topics (目次) ----------------
  const TOPICS = [
    "01 データの単位","02 数値の数え方","03 基数変換と桁の話","04 さまざまな記数法変換",
    "05 負の2進数","06 2進数の四則演算",
    "07 集合と論理演算","08 論理回路","09 計算式の表し方","10 オートマトン","11 AI（人工知能）",
    "12 データ構造","13 アルゴリズムの基本","14 アルゴリズムの分類","15 プログラムの性質と種類","16 その他の言語",
    "17 CPU（プロセッサ）","18 CPUが処理する流れ","19 記憶装置","20 入出力装置",
    "21 システムの分類","22 システム構成による分類","23 システムの性能指標","24 システムの信頼性指標",
    "25 OS","26 データ管理とファイルシステム","27 バックアップ","28 開発ツール","29 オープンソースソフトウェア",
    "30 半導体メモリ","31 電子回路",
    "32 ヒューマンインターフェース技術","33 インタフェース設計","34 マルチメディア技術",
    "35 データベースの基本","36 関係データベース","37 データベース設計","38 データベース管理システム",
    "39 トランザクション管理","40 排他制御",
    "41 回線","42 LANとWAN","43 IPアドレス","44 サブネットマスク","45 グローバル/プライベートIP",
    "46 ドメイン名","47 通信プロトコル","48 インターネット応用",
    "49 セキュリティの脅威","50 暗号技術の基本","51 デジタル署名と認証局","52 リスクマネジメント",
    "53 セキュリティマネジメント","54 脅威への対策",
    "55 システム開発技術","56 システム要件定義","57 システム設計","58 プログラミングとオブジェクト指向","59 テスト",
    "60 ソフトウェア開発モデル",
    "61 プロジェクトマネジメント","62 スコープマネジメント","63 リソースマネジメント","64 タイムマネジメント",
    "65 コストマネジメント","66 リスクマネジメント",
    "67 サービスマネジメント","68 サービスレベル管理","69 サービスデスク","70 ファシリティマネジメント",
    "71 システム監査","72 内部統制",
    "73 情報システム戦略","74 業務プロセス","75 ソリューションビジネス","76 活用促進と評価",
    "77 システム企画","78 調達計画・実施",
    "79 経営戦略","80 会社戦略","81 事業戦略","82 評価","83 マーケティング","84 組織マネジメント","85 財務",
    "86 法務","87 知的財産","88 セキュリティ関連法","89 労働関連法",
    "90 試験対策（科目Bの合格戦略）"
  ];
  const INTERVALS = [0, 0.5, 1, 2, 3, 4, 5, 6, 7];
  const COL_KEYS = ["init","0","0.5","1","2","3","4","5","6","7"]; // init + intervals
  const STORAGE_KEY = "fe_memory_plan_v1";

  // --------- helpers ---------
  const fmtYMD = (d) => d.toISOString().slice(0,10);
  const fmtMD = (d) => `${String(d.getMonth()+1).padStart(2,"0")}/${String(d.getDate()).padStart(2,"0")}`;
  function addDays(base, days){
    const ms = base.getTime() + days*24*60*60*1000;
    return new Date(ms);
  }
  function allocate(topics, startDate, perDay){
    const plan = []; // [{topic, dates:{init, "0","0.5","1"...}}]
    let dayIndex = 0;
    for (let i=0; i<topics.length; ){
      const count = Math.min(perDay, topics.length - i);
      const initial = addDays(startDate, dayIndex);
      for (let k=0; k<count; k++){
        const t = topics[i+k];
        const dates = {"init": fmtYMD(initial)};
        for (const iv of INTERVALS){
          const d = addDays(initial, iv);
          const key = String(iv);
          dates[key] = fmtYMD(d);
        }
        plan.push({topic: t, dates});
      }
      i += count;
      dayIndex += 1;
    }
    return plan;
  }

  // --------- state ---------
  let startDate = new Date();
  let perDay = 3;
  let plan = [];           // allocate result
  let progress = {};       // { startDateYMD: { "<topicIndex>|<colKey>": true } }

  // Load progress
  function loadProgress(){
    try{
      progress = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}");
    }catch{ progress = {}; }
  }
  function saveProgress(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  }
  function getKeyForDate(d){ return fmtYMD(d); }

  // mark helpers
  function isDone(topicIndex, colKey){
    const planKey = getKeyForDate(startDate);
    const store = progress[planKey] || {};
    return !!store[`${topicIndex}|${colKey}`];
  }
  function toggleDone(topicIndex, colKey){
    const planKey = getKeyForDate(startDate);
    if(!progress[planKey]) progress[planKey] = {};
    const k = `${topicIndex}|${colKey}`;
    progress[planKey][k] = !progress[planKey][k];
    saveProgress();
  }

  // --------- UI build ---------
  const tbody = document.getElementById("tbody");
  function rebuildGrid(){
    tbody.innerHTML = "";
    // header inputs reflect
    document.getElementById("startDate").value = fmtYMD(startDate);
    document.getElementById("perDay").value = perDay;
    const todayYMD = fmtYMD(new Date());

    plan = allocate(TOPICS, startDate, perDay);

    plan.forEach((row, idx) => {
      const tr = document.createElement("tr");
      // topic cell
      const tdTopic = document.createElement("td");
      tdTopic.className = "sticky-first p-2 border-b border-gray-200 bg-white";
      tdTopic.textContent = row.topic;
      tr.appendChild(tdTopic);

      // columns: init + intervals
      // init
      const initDate = row.dates["init"];
      tr.appendChild(makeCell(idx, "init", initDate, todayYMD));

      for (const iv of INTERVALS){
        const key = String(iv);
        const d = row.dates[key];
        const label = key === "0.5" ? d + " 夜" : d;
        tr.appendChild(makeCell(idx, key, label, todayYMD, d));
      }
      tbody.appendChild(tr);
    });

    renderTodayList();
  }

  function makeCell(idx, colKey, label, todayYMD, rawYMD=null){
    const td = document.createElement("td");
    td.className = "cell text-center p-2 border-b border-gray-100";
    td.dataset.idx = idx;
    td.dataset.col = colKey;
    td.title = label;

    // visual date (MM/DD) only
    const ymd = (rawYMD || label).slice(0,10);
    const d = new Date(ymd);
    const visual = (colKey==="0.5") ? fmtMD(d) + " 夜" : fmtMD(d);
    td.innerHTML = `<span class="small">${visual}</span>`;

    // state
    if (isDone(idx, colKey)) td.classList.add("done");
    if (ymd < todayYMD) td.classList.add("overdue");
    if (ymd === todayYMD) td.classList.add("today");

    // toggle
    td.addEventListener("click", () => {
      toggleDone(idx, colKey);
      td.classList.toggle("done");
    });
    return td;
  }

  // --------- Today list ---------
  function renderTodayList(){
    const box = document.getElementById("todayList");
    const today = new Date();
    const todayYMD = fmtYMD(today);
    const items = [];
    plan.forEach((row, idx) => {
      for (const key of COL_KEYS){
        const ymd = row.dates[key];
        if (!ymd) continue;
        if (ymd === todayYMD){
          const title = (key==="0.5") ? `${row.topic}（夜）` : row.topic;
          items.push({idx, key, title});
        }
      }
    });
    if (!items.length){
      box.innerHTML = `<p class="text-gray-500">本日分はありません。</p>`;
      return;
    }
    // list
    box.innerHTML = "";
    const ul = document.createElement("ul");
    ul.className = "list-disc ml-5";
    items.forEach(item => {
      const li = document.createElement("li");
      const btn = document.createElement("button");
      btn.className = "underline text-blue-600";
      btn.textContent = item.title;
      btn.addEventListener("click", () => {
        // toggle and sync cell
        toggleDone(item.idx, item.key);
        // find cell and toggle class
        const selector = `td.cell[data-idx="${item.idx}"][data-col="${item.key}"]`;
        const cell = document.querySelector(selector);
        if (cell) cell.classList.toggle("done");
      });
      li.appendChild(btn);
      ul.appendChild(li);
    });
    box.appendChild(ul);
  }

  // --------- Controls ---------
  document.getElementById("rebuildBtn").addEventListener("click", () => {
    const d = document.getElementById("startDate").value;
    startDate = d ? new Date(d+"T00:00:00") : new Date();
    perDay = Math.max(1, Math.min(10, parseInt(document.getElementById("perDay").value||"3",10)));
    rebuildGrid();
  });
  document.getElementById("todayBtn").addEventListener("click", () => {
    const todayYMD = fmtYMD(new Date());
    const cell = document.querySelector(`td.cell.today`);
    if (cell) cell.scrollIntoView({behavior:"smooth", block:"center"});
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    if (!confirm("すべての塗りつぶしを消去します。よろしいですか？")) return;
    const key = getKeyForDate(startDate);
    if (progress[key]) delete progress[key];
    saveProgress();
    rebuildGrid();
  });
  document.getElementById("exportBtn").addEventListener("click", () => {
    const dataStr = JSON.stringify(progress, null, 2);
    const blob = new Blob([dataStr], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "fe_memory_progress.json";
    a.click();
  });
  document.getElementById("importInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        progress = JSON.parse(reader.result);
        saveProgress();
        rebuildGrid();
        alert("インポートしました。");
      }catch(err){
        alert("JSONの読み込みに失敗しました。");
      }
    };
    reader.readAsText(file);
  });

  // --------- init ---------
  (function init(){
    loadProgress();
    const d = new Date();
    document.getElementById("startDate").value = fmtYMD(d);
    startDate = d;
    perDay = 3;
    rebuildGrid();
  })();
  </script>
</body>
</html>
