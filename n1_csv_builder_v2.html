
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JLPT N1 語彙CSVメーカー v2（重複なし・最大3000）</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .btn{padding:.5rem .75rem;border-radius:.5rem;font-weight:600}
  .btn-primary{background:#2563eb;color:#fff}
  .btn-secondary{background:#e5e7eb}
</style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-3xl mx-auto p-4 space-y-4">
    <h1 class="text-2xl font-bold">JLPT N1 語彙CSVメーカー v2（重複なし・最大3000）</h1>
    <p class="text-sm text-gray-600">ミラーURLと堅牢なCSVパーサを追加。GitHub Pages（https）上で実行することを推奨します。</p>

    <div class="bg-white rounded shadow p-4 space-y-3">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div>
          <label class="block text-sm text-gray-600 mb-1">出題数（最大3000）</label>
          <input id="limitInput" type="number" min="100" max="3000" value="3000" class="w-full p-2 border rounded" />
        </div>
        <div>
          <label class="block text-sm text-gray-600 mb-1">意味の表示</label>
          <select id="meaningMode" class="w-full p-2 border rounded">
            <option value="en">英語（出典そのまま）</option>
            <option value="jp-lite">日本語（簡易変換）</option>
          </select>
        </div>
        <div class="flex items-end">
          <button id="buildBtn" class="btn btn-primary w-full">取得してCSVを作る</button>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="saveBtn" class="btn btn-secondary" disabled>CSVを保存</button>
        <span id="countInfo" class="text-sm text-gray-600"></span>
      </div>
    </div>

    <details class="bg-white rounded shadow p-4">
      <summary class="cursor-pointer font-semibold">診断ログ（開く）</summary>
      <pre id="log" class="mono text-xs mt-2 whitespace-pre-wrap"></pre>
    </details>
  </div>

<script>
const $ = (id) => document.getElementById(id);
const log = (m) => { const el = $("log"); el.textContent += m + "\\n"; el.scrollTop = el.scrollHeight; };
const uniqBy = (arr, key) => { const s = new Set(); return arr.filter(x => { const k = key(x); if (s.has(k)) return false; s.add(k); return true; }); };

// Robust CSV parser (handles quotes, commas, newlines in fields)
function parseCSV(text) {
  const rows = [];
  let i = 0, field = '', row = [], inQuotes = false;
  while (i < text.length) {
    const c = text[i];
    if (inQuotes) {
      if (c === '"') {
        if (text[i+1] === '"') { field += '"'; i++; }
        else { inQuotes = false; }
      } else { field += c; }
    } else {
      if (c === '"') { inQuotes = true; }
      else if (c === ',') { row.push(field); field = ''; }
      else if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; }
      else if (c === '\r') { /* skip */ }
      else { field += c; }
    }
    i++;
  }
  if (field.length || row.length) { row.push(field); rows.push(row); }
  return rows;
}

async function fetchWithTimeout(url, ms=15000) {
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), ms);
  try {
    const res = await fetch(url, {signal: ctrl.signal, cache: "no-store"});
    return res;
  } finally { clearTimeout(t); }
}

// Multiple mirrors for each dataset
const OPEN_ANKI_URLS = [
  "https://raw.githubusercontent.com/jamsinclair/open-anki-jlpt-decks/main/src/n1.csv",
  "https://cdn.jsdelivr.net/gh/jamsinclair/open-anki-jlpt-decks@main/src/n1.csv",
  "https://raw.githubusercontent.com/jamsinclair/open-anki-jlpt-decks/master/src/n1.csv",
  "https://cdn.jsdelivr.net/gh/jamsinclair/open-anki-jlpt-decks@master/src/n1.csv"
];
const ELZUP_URLS = [
  "https://raw.githubusercontent.com/elzup/jlpt-word-list/master/out/jlpt-n1.json",
  "https://cdn.jsdelivr.net/gh/elzup/jlpt-word-list@master/out/jlpt-n1.json"
];
const BLUSKYO_URLS = [
  "https://raw.githubusercontent.com/Bluskyo/JLPT_Vocabulary/master/N1.json",
  "https://cdn.jsdelivr.net/gh/Bluskyo/JLPT_Vocabulary@master/N1.json"
];

async function tryFetchJSON(urls) {
  for (const url of urls) {
    try {
      log("Fetch " + url + " ...");
      const res = await fetchWithTimeout(url);
      if (res.ok) {
        const json = await res.json();
        log("OK " + url);
        return json;
      } else {
        log("NG " + url + " => " + res.status);
      }
    } catch(e) {
      log("ERR " + url + " => " + e);
    }
  }
  return null;
}

async function tryFetchText(urls) {
  for (const url of urls) {
    try {
      log("Fetch " + url + " ...");
      const res = await fetchWithTimeout(url);
      if (res.ok) {
        const text = await res.text();
        log("OK " + url);
        return text;
      } else {
        log("NG " + url + " => " + res.status);
      }
    } catch(e) {
      log("ERR " + url + " => " + e);
    }
  }
  return null;
}

async function fetchOpenAnkiN1Csv() {
  const text = await tryFetchText(OPEN_ANKI_URLS);
  if (!text) return [];
  const rows = parseCSV(text);
  // Find indexes by header row
  let header = rows[0] || [];
  const idxExpression = header.indexOf("expression");
  const idxGloss = header.indexOf("gloss");
  const idxPos = header.indexOf("pos");
  const out = [];
  for (let i=1;i<rows.length;i++){
    const r = rows[i];
    const word = (idxExpression>=0 ? r[idxExpression] : r[0] || "").trim();
    const meaning_en = (idxGloss>=0 ? r[idxGloss] : r[2] || r[3] || "").trim();
    const pos = (idxPos>=0 ? r[idxPos] : r[3] || "").trim();
    if (word && meaning_en) out.push({word, meaning_en, pos, source: "open-anki"});
  }
  log("OpenAnki parsed: " + out.length + " 語");
  return out;
}

async function fetchElzupJsonN1() {
  const json = await tryFetchJSON(ELZUP_URLS);
  if (!json) return [];
  const out = (Array.isArray(json) ? json : []).map(x => ({
    word: x.expression || x.word || "",
    meaning_en: (x.gloss || x.meaning || "").toString(),
    pos: (x.pos||"").toString(),
    source: "elzup"
  })).filter(x => x.word && x.meaning_en);
  log("elzup parsed: " + out.length + " 語");
  return out;
}

async function fetchBluskyoN1Json() {
  const json = await tryFetchJSON(BLUSKYO_URLS);
  if (!json) return [];
  const out = (Array.isArray(json) ? json : []).map(x => ({
    word: x.kanji || x.kana || "",
    meaning_en: (x.english || "").toString(),
    pos: (x.pos || "").toString(),
    source: "bluskyo"
  })).filter(x => x.word && x.meaning_en);
  log("Bluskyo parsed: " + out.length + " 語");
  return out;
}

// quick JP converter (lite)
function toJapaneseLite(english) {
  let j = english || "";
  j = j.replace(/^to\s+/i, "〜する：");
  j = j.replace(/\bperson\b/ig, "人");
  j = j.replace(/\bsomeone\b/ig, "人");
  j = j.replace(/\bsomething\b/ig, "物");
  j = j.replace(/\bthing\b/ig, "物");
  j = j.replace(/\bstate\b/ig, "状態");
  j = j.replace(/\baction\b/ig, "行為");
  return j;
}

function buildCsv(rows, limit, mode) {
  let items = uniqBy(rows, x => x.word);
  if (limit && items.length > limit) items = items.slice(0, limit);
  const header = ["No","単語","意味","品詞","出典"];
  const lines = [header.join(",")];
  const esc = (s) => `"${String(s).replace(/"/g, '""')}"`;
  items.forEach((r, i) => {
    const meaning = mode==="jp-lite" ? toJapaneseLite(r.meaning_en) : r.meaning_en;
    lines.push([i+1, esc(r.word), esc(meaning), esc(r.pos||""), esc(r.source||"")].join(","));
  });
  return lines.join("\n");
}

(async function init(){
  $("buildBtn").onclick = async () => {
    $("buildBtn").disabled = true;
    $("saveBtn").disabled = true;
    $("countInfo").textContent = "取得中…";
    $("log").textContent = "";

    const [a,b,c] = await Promise.all([
      fetchOpenAnkiN1Csv(),
      fetchElzupJsonN1(),
      fetchBluskyoN1Json()
    ]);
    const merged = [...a, ...b, ...c];
    const deduped = uniqBy(merged, x => x.word);
    const limit = Math.max(100, Math.min(3000, parseInt($("limitInput").value || "3000", 10)));
    const mode = $("meaningMode").value;
    const csv = buildCsv(deduped, limit, mode);

    window._csvBlob = new Blob([csv], {type: "text/csv;charset=utf-8"});
    const count = csv.split("\n").length - 1;
    $("countInfo").textContent = `生成済み：${count} 語（重複除去後）`;
    $("saveBtn").disabled = false;
    $("buildBtn").disabled = false;
  };

  $("saveBtn").onclick = () => {
    if (!window._csvBlob) return;
    const a = document.createElement("a");
    a.href = URL.createObjectURL(window._csvBlob);
    a.download = "n1_vocab_uniq.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
  };
})();
</script>
</body>
</html>
